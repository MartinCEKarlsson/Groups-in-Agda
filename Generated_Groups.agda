{-# OPTIONS --without-K --rewriting #-}

open import lib.Base
open import lib.NType
open import lib.types.List
open import lib.types.Sigma
open import lib.Funext
open import lib.types.Truncation

open import Group-basics

{- In this file we work on the extra goal. Given a group G with carrier X, a
   group generated by a subset X' of X is the smallest subgroup of G containing
   X'.
-}
module Generated_Groups where

module Basics {α : ULevel} where
  ∥_∥ = Trunc {α} (-1)

  {- A word is an ordered list of elemnents. -}
  Word : (A : Type α) → Type α
  Word A = List A

  {- A subset is function that selects element from the type. -}
  Subset : (A : Type α) → Type (lsucc α)
  Subset A = Σ (A → Type α) λ x → ∀ {a : A} → is-prop (x a)

  {- A subset word is a word and a proof that it contains only elementes in the
     subset. -}
  SubsetWord : {A : Type α} → (Subset A) → Type α
  SubsetWord {A} (prop , isprop) = Σ (Word A) λ W → All prop W

module _ {α : ULevel} {G : Group {α}} where
  private
    module G = Group G
    _·_ = G.comp
    open Basics {α}

  {- Compose element from word. -}
  word→U : Word G.U → G.U
  word→U nil = G.e
  word→U (x :: wrd) = x G.· word→U wrd

  {- Compose element from word consisting of elements in a subset. -}
  sword→U : {A : Subset G.U} → SubsetWord A → G.U
  sword→U {A} (word , all) = word→U word

  {- We need to add some conditions to this such that it is the smallest
     subgroup containing the subset.
  -}
  record GeneratedGroup : Type (lsucc α) where
    field
      set : Subset G.U

  {- This is the first part of the proof. A generated group by a subset of
     the carrier of some group is a subgroup of that group.
  -}
  GeneratedGroup-is-Subgroup : GeneratedGroup → Subgrp G
  GeneratedGroup-is-Subgroup GG = record { prop = prop
                                         ; f = Trunc-level
                                         ; id = [ (nil , nil) , idp ]
                                         ; comp = comp
                                         ; inv = inv }
     where
       open GeneratedGroup GG
       {- Words over the subset. -}
       words : Type α
       words = SubsetWord set

       {- Selector for all elements in the generated group. -}
       prop : G.U → Type α
       prop a = ∥ Σ words (λ x → sword→U {set} x == a) ∥

       {- This is trivial if we can assume a and b are in the subset. However,
          they might already be compositions of subset words. I guess we need
          some kind of recursive argument. -}
       comp : {a b : G.U} → prop a → prop b → prop (G.comp a b)
       comp {a} {b} pa pb = {!   !}

       {- This doesnt seem necessarily true? The current condition only closes
          under the operation, not inverse. -}
       inv : {a : G.U} → prop a → prop (G.i a)
       inv {a} pa = [ {!   !} , {!   !} ]
