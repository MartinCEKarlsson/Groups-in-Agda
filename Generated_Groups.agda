{-# OPTIONS --without-K --rewriting #-}

open import lib.Base
open import lib.NType
open import lib.types.List
open import lib.PathGroupoid
open import lib.types.Sigma
open import lib.Funext
open import lib.types.Truncation
open import Group-basics

{- In this file we work on the extra goal. Given a group G with carrier X, a
   group generated by a subset X' of X is the smallest subgroup of G containing
   X'.
-}
module Generated_Groups {α : ULevel} {G : Group {α}} where

{- We set up do notation as shown in the example file. -}
module DoNotation where

  ∥_∥ = Trunc {α} (-1)

  infix 10 ∥_∥

  _>>=_ : {X Y : Type α} → ∥ X ∥ → (X → ∥ Y ∥) → ∥ Y ∥
  _>>=_ xt f = Trunc-rec f xt

  return = [_]


private
  open DoNotation
  module G = Group G
  _·_ = G.comp

{- A word is an ordered list of coproducts. Elements injected from the left
   will be ordinary elemetns. Elements injected from the right are inverses.
-}
Word : Type α
Word = List (Coprod G.U G.U)

apply : (f : G.U → Type α) → Coprod G.U G.U → Type α
apply f (inl a) = f a
apply f (inr a) = f a

apply' : (f : G.U → Type α) → Coprod G.U G.U → Type α
apply' f (inl a) = f a
apply' f (inr a) = f (G.i a)

get : Coprod G.U G.U → G.U
get (inl a) = a
get (inr a) = a

{- A subset is function that selects element from the type. -}
Subset : Type (lsucc α)
Subset = Σ (G.U → Type α) λ x → ∀ {a : G.U} → is-prop (x a)

{- A subset word is a word and a proof that it contains only elements in the
   subset. -}
SubsetWord : Subset → Type α
SubsetWord (prop , isprop) = List (Σ (Coprod G.U G.U) (apply' prop))

{- In this module we define some operations of words in a subset. -}
module _ {s : Subset} where
  {- First, we define a mapping from words to elements in the carrier in the
     obivous way.
  -}
  sword→U : SubsetWord s → G.U
  sword→U nil = G.e
  sword→U ((x , _) :: s) = get x · sword→U s

  {- We want the mapping to be compatible with concatenation. -}
  sword++ : (a b : SubsetWord s) → (sword→U a · sword→U b) == (sword→U (a ++ b))
  sword++ nil b = G.unit-l (sword→U b)
  sword++ ((inl x , Px) :: a) b =
    G.associative x (sword→U a) (sword→U b) ∙ ap (λ φ → x · φ) (sword++ a b)
  sword++ ((inr x , Px) :: a) b =
    G.associative x (sword→U a) (sword→U b) ∙ ap (λ φ → x · φ) (sword++ a b)

  {- Next we want a notion of word inverses such that the fulfil the following
     property: if sword→U w == a then sword→U w⁻¹ == a⁻¹.
  -}
  sword-inv : SubsetWord s → SubsetWord s
  sword-inv nil = nil
  sword-inv ((inl x , Px) :: sw) = (sword-inv sw) ++ (((inr (G.i x)) ,
    transport (λ y → fst s y) (! ( G.inv-inv-is-unit x)) Px) :: nil)
  sword-inv ((inr x , Px) :: sw) = (sword-inv sw) ++ (((inl (G.i x)) ,
    transport (λ y → fst s (G.i y)) idp Px) :: nil)

  private
    inverse-lemma : {x : G.U} → fst s x → fst s (G.i (G.i x))
    inverse-lemma x = transport (λ y → fst s y) (! (G.inv-inv-is-unit _)) x

  {- We now show that our inverse has the desired property. -}
  sword→U-inv : {a : G.U} (sw : SubsetWord s)
              → sword→U sw == a
              → (sword→U (sword-inv sw)) == G.i a
  sword→U-inv nil idp = G.unit-is-inv-unit
  sword→U-inv {a} ((inl x , Px) :: sw) idp =
      sword→U (sword-inv sw ++ (((inr (G.i x)) , inverse-lemma Px) :: nil))
    =⟨ ! (sword++ (sword-inv sw) ((((inr (G.i x)) , inverse-lemma Px) :: nil))) ⟩
      sword→U (sword-inv sw) · sword→U (((inr (G.i x)) , inverse-lemma Px) :: nil)
    =⟨ ap (λ φ → sword→U (sword-inv sw) · φ) (G.unit-r (G.i x)) ⟩
      sword→U (sword-inv sw) · (G.i x)
    =⟨ ap (λ φ → φ · (G.i x)) (sword→U-inv sw idp) ⟩
      (G.i (sword→U sw)) · (G.i x)
    =⟨ G.inv-of-comp x (sword→U sw) ⟩
      G.i (x · sword→U sw)
    =∎
  sword→U-inv ((inr x , Px) :: sw) idp =
      sword→U (sword-inv sw ++ (((inl (G.i x)) , Px) :: nil))
    =⟨ ! (sword++ (sword-inv sw) (((inl (G.i x)) , Px) :: nil)) ⟩
      sword→U (sword-inv sw) · sword→U (((inl (G.i x)) , Px) :: nil)
    =⟨ ap (λ φ → sword→U (sword-inv sw) · φ) (G.unit-r (G.i x)) ⟩
      (sword→U (sword-inv sw) · (G.i x))
    =⟨ ap (λ φ → φ · (G.i x)) (sword→U-inv sw idp) ⟩
      (G.i (sword→U sw) · G.i x)
    =⟨ G.inv-of-comp x (sword→U sw) ⟩
      G.i (x · sword→U sw)
    =∎

{- Now we define a group generated by a subset to be all elements mapped to by
   sword→U of words over the subset.
-}
GeneratedGroup : Subset → Subgrp G
GeneratedGroup set = record { prop = prop
                            ; f = Trunc-level
                            ; id = [ nil , idp ]
                            ; comp = comp
                            ; inv = inv }
   where
     {- Words over the subset. -}
     words : Type α
     words = SubsetWord set

     {- Selector for all elements in the generated group. -}
     prop : G.U → Type α
     prop a = ∥ Σ words (λ x → sword→U {set} x == a) ∥

     {- Composition follows from the compatibility of sword→U. -}
     comp : {a b : G.U} → prop a → prop b → prop (a · b)
     comp {a} {b} pa pb =
      do
        (u , p) ← pa
        (v , q) ← pb
        return {α} (u ++ v , ! (sword++ u v) ∙ ap (λ φ → φ · sword→U v) p ∙ ap (λ φ → a · φ) q)

     {- Inverses follow from our definition of inverse words. -}
     inv : {a : G.U } → prop a → prop (G.i a)
     inv {a} pa =
      do
        x ← pa
        return {α} (sword-inv (fst x) , sword→U-inv (fst x) (snd x))
